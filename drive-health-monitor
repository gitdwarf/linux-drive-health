#!/bin/bash

# This script requires running as full root to work properly
# Checks SMART status on drives, aggressively alerts if problems found,
# then performs TRIM and XFS defrag if relevant on specified drives
# if (and only if) ALL drives report healthy.
# Test usage: (as full root, running as sudo it not enough)
# ./drive-health-monitor --test
# aking to pressing the test button a smoke alarm

### User Variables START ###
machineID="machineID" # Your computer/server name or ID
notifyemail="YOUREMAILHERE" # eg you@example.com
unmounteddrvs="/dev/unmounteddrv1 /dev/unmounteddrv2" # These are any normally unmounted fixed partitions or drives you may have eg. hot spares or recovery/rescue partions (space seperated).
mountbase="/scratch/mount/point"  # Scratch mount point to mount the above unmounted drives/partions.
xfsdrives="/dev/xfshdd1 /dev/xfshdd2" # These are any XFS formatted spinning disk HDDs you may have (space seperated). DO NOT put SSDs here, they will be ignored.

### User Variables END ###


## Script starts here ##

set -euo pipefail
shopt -s nullglob

# Check if runnning as full root (vs as user, or even with sudo)
# Must be real root, not sudo
notroot="ERROR: This script must be run as FULL ROOT"
fullroot="Use:  su -   or   sudo -s   or   sudo -i"
# Reject if not root at all
if [ "$(id -u)" -ne 0 ] || \
[ "$(ps -o comm= -p "$(ps -o ppid= -p $$ | tr -d ' ')" 2>/dev/null || echo unknown)" = "sudo" ]
then
  # Reject if root *via sudo*
  [ -n "${SUDO_USER:-}" ] && notroot=$"${notroot} (not sudo)"
    echo $"${notroot}"
    echo $"${fullroot}"
    exit 1
fi

# Parse command line arguments for testing
testmode=0
while [ $# -gt 0 ]; do
  case "$1" in
    --test|-test)
      testmode=1
      shift
      ;;
    *)
      echo "Unknown option: $1"
      echo "Usage: $0 [--test]"
      exit 1
      ;;
  esac
done

# If uservars unchanged, set them to sensible defaults
[ "${machineID}" == "MachineID" ] && machineID="Your Computer"
[ "${notifyemail}" == "YOUREMAILHERE" ] && notifyemail="root"
[ "${unmounteddrvs}" == "/dev/unmounteddrv1 /dev/unmounteddrv2" ] && unmounteddrvs=""
[ "${mountbase}" == "/scratch/mount/point" ]  && mkdir -p /tmp/drvchkmount && mountbase=/tmp/drvchkmount
[ "${xfsdrives}" == "/dev/xfshdd1 /dev/xfshdd2" ] && xfsdrives=""
alert_email=""
baddrive=0
wayland=0
smartctltest="PASSED"
testheader=""
alert_emailsubject="CRITICAL ERROR ALERT ON A DRIVE ON ${machineID}"
notify_urgency="critical"
notify_title="              HDD SMART ALERT!"
zenity_urgency="--error"

# Detect any Wayland sessions
for de in $(loginctl list-sessions --no-legend | awk '{print $1}'); do
  [ "$(loginctl show-session "${de}" -p Type --value)" = "wayland" ] && { wayland=1; break 1; }
done

# Notification daemons
wayland_daemons=(mako waybar-notify)
x_daemons=(
  "/usr/lib64/xfce4/notifyd/xfce4-notifyd"
  "dunst"
  "mate-notification-daemon"
  "notify-osd"
)

fn_smartcheck() {
  # Check SMART support
  if [ "${testmode}" == "1" ] ; then
  testheader="\n  !JUST A TEST! \n"
  alert_emailsubject="TESTING OF DRIVE ALERTS FOR ${machineID}"
  smartctltest="TESTING"
  notify_urgency="normal"
  notify_title="       TESTING OF HDD SMART ALERT!"
  zenity_urgency="--info"
  fi

  if smartctl -i "${drivecheck}" 2>/dev/null | grep -q "SMART support is: Available"; then
    if ! smartctl -H "${drivecheck}" | grep -q "${smartctltest}"; then
      baddrive=1
      alert_alert="ALERT! ALERT! ALERT! ALERT!"
      alert_txt="Drive ${drivecheck} reporting SMART error!"
      alert_combined="${testheader}\n  ${alert_alert} \n${testheader}\n${alert_txt} \n${testheader}\n  ${alert_alert} \n${testheader}"

      alert_email="${alert_email} ${alert_combined}"

      # Start all notification daemons (silently ignore any that arent installed and so fail to start)
      [ "${wayland}" = "1" ] && for daemon in "${wayland_daemons[@]}"; do "${daemon}" &>/dev/null & done
      for daemon in "${x_daemons[@]}"; do "${daemon}" &>/dev/null & done

      # Notify all logged-in GUI sessions
      users=$(who | awk '{print $1}' | sort -u)
      for user in $users; do
        runuser -u "$user" -- notify-send -u ${notify_urgency} $"${notify_title}" $"${alert_combined}" &>/dev/null &
        runuser -u "$user" -- zenity "${zenity_urgency}" --text=$"${alert_combined}" &>/dev/null &
      done

      # Send alert to all logged in terminals and TTYs too
      # Pseudo-terminals (ssh, xterm, tmux, etc)
      for pts in /dev/pts/[0-9]*; do
        [ -w "$pts" ] && printf "%b\n" $"${alert_combined}" > "$pts" 2>/dev/null
      done

      # Real virtual terminals (tty1â€“tty63)
      for tty in /dev/tty[0-9]*; do
        [ -w "$tty" ] && printf "%b\n" $"${alert_combined}" > "$tty" 2>/dev/null
      done

    fi
  else
    echo "Skipping ${drivecheck} - SMART not supported"
  fi
}

fn_xfsdrvs() {
  xfsoutput=$(xfs_fsr "${drive}" 2>&1 | grep -v "start inode=0" || true)
  if [ -n "${xfsoutput}" ]; then
    xfsalert="There was an error or warning when running xfs_fsr on drive ${drive}: ${xfsoutput}"
    alert_email="${alert_email} ${xfsalert}"
    alert_emailsubject="${machineID} xfs_fsr error or warning"
  fi
}

echo "Checking SMART status on drives"

# NVMe
nvme_drives=(/dev/nvme?n?)
if [ ${#nvme_drives[@]} -ne 0 ]; then
  for drivecheck in "${nvme_drives[@]}"; do
    fn_smartcheck
  done
fi

# SATA / USB
sd_drives=(/dev/sd?)
if [ ${#sd_drives[@]} -ne 0 ]; then
  for drivecheck in "${sd_drives[@]}"; do
    fn_smartcheck
  done
fi

# If all drives healthy, perform TRIM / XFS defrag
if [ "${baddrive}" -eq 0 ]; then
  # Mount unmounted drives and TRIM them
  for drv in "${unmounteddrvs[@]}"; do
    if ! mount | grep -q "on ${mountbase} "; then
      mount "${drv}" "${mountbase}"
      while ! mount | grep -q "${drv} "; do sleep 0.5; done
      /sbin/fstrim "${mountbase}" --verbose --quiet
      umount "${mountbase}"
      while mount | grep -q "${drv} "; do sleep 0.5; done
    else
      echo "Mount point ${mountbase} already in use - unmounted ${drv} TRIM skipped"
    fi
  done

  # TRIM all compatable mounted drives
  /sbin/fstrim --all --verbose --quiet

  # Defrag any XFS drives (only rotational)
  if ! pgrep -i xfs_fsr >/dev/null; then
    for drive in ${xfsdrives}; do
      # Check if drive is rotational
      is_rot=$(lsblk -d -o rota -n "${drive}" | tr -d ' ')
      if [ "${is_rot}" -eq 1 ]; then
        # Only defrag if not already mounted and mount point free
        if ! mount | grep -q "${drive} "; then
          if ! mount | grep -q "on ${mountbase} "; then
            mount "${drive}" "${mountbase}"
            while ! mount | grep -q "${drive} "; do sleep 0.5; done
            fn_xfsdrvs
            umount "${mountbase}"
            while mount | grep -q "${drive} "; do sleep 0.5; done
          else
            echo "Mount point ${mountbase} in use - ${drive} defrag skipped"
          fi
        else
          fn_xfsdrvs
        fi
      else
        echo "Drive ${drive} is SSD or non-spinning, skipping defrag"
      fi
    done
    echo "Defrag completed for drives: ${xfsdrives}"
  else
    echo "xfs_fsr already running - skipping defrag"
  fi
fi

# Send alert email if needed
alert_email="$(printf "%b\n" $"${alert_email}")"
[ -n "${alert_email}" ] && mail -s "${alert_emailsubject}" "${notifyemail}" <<< $"${alert_email}"

## Script ends ##
